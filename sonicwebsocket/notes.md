## What websocket is about
- layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits. So everything on the IP level is done in packets.
- it tries to be as much as possible close to raw tcp

## Misc
- URI: wss://host:port/path?query
- wss is 443 by default
- ws is 80 by default

## Opening handshake
The handshake from the client looks as follows:
```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13

```

The handshake from the server looks as follows:
```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

- the client might request the server to use a different subprotocol through the `Sec-Websocket-Protocol` header

## Closing handshake
- each peer sends the control frame to one another
- the peer which sent and received a close control frame, can close the tcp connection
- after sending a close control frame, a peer stops sending any more data

## Communication
- once the handshake is complete, bidirectional communication may start
- the two parties send each other **messages**
- on the wire, a **message** is composed of one or more frames

- each frame has a type (each frame belonging to the same message has the same type):
  - type textual data
  - type binary data
  - type control frames

- a client must mask all frames that it sends to the server, even if the protocol is running over TLS
- a server must not mask any frames sent to the client
- a clients must close the connection if it detects masked frames (with some status code)
- server must close the connection upon receiving an unmasked frame

- payload data is extension data + application data
- extension data is present only if some extension has been negotiated

- i think masking keys are picked new for each frame

### Fragmentation
- it's good to fragment when using multiplexing the channel so not one producer/consumer can monopolize the channel with its huge messages

- unfragmented message: single frame with FIN bit set and an opcode other than 0 (opcode 0 denotes a continuation frame)
- fragmented message:
  - single frame with FIN bit clear and an opcode other than 0
  - followed by zero or more frames with the FIN bit clear and the opcode set to 0
  - terminated by a single frame with the FIN bit set and an opcode of 0.
  - payload data between fragments is then concatenated

- control frames may be injected in the middle of a fragmented message. Control frames MUST NOT be fragmented
- messages must be delivered to the recipient in the order generated by the sender (ensured by TCP)
- the fragments of one message must not be interleaved between the fragments of another message.
- an endpoint must be capable of handling control frames in the middle of a fragmented message
- a sender may create fragments of any size for non-control messages
- all fragments of a message are of the same type, as set by the first fragment's opcode.
- since control frames cannot be fragmented, the type for all fragments in a message must be either text, binary or one of the reserved opcodes.

- all control frames must have a length of 125 or less and must not be fragmented.


data frame is any frame that's not a control frame
